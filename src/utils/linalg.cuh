#pragma once

/**
 * Linear algebra helpers.
 * James Perlman, 2023 - much of this was generated by Copilot.
 * 
 * Eigen is not building with C++20, and there are some performance benefits to writing our own linear algebra helpers.
 * This is the bare minimum of what we need to run NeRF.
 * 
 */

#include <cuda_runtime.h>
#include <json/json.hpp>
#include "../common.h"

NRC_NAMESPACE_BEGIN

struct Matrix4f
{
    float m00, m01, m02, m03;
    float m10, m11, m12, m13;
    float m20, m21, m22, m23;
    float m30, m31, m32, m33;

    Matrix4f() = default;

    Matrix4f(
        float m00, float m01, float m02, float m03,
        float m10, float m11, float m12, float m13,
        float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33
    ) : m00(m00), m01(m01), m02(m02), m03(m03),
        m10(m10), m11(m11), m12(m12), m13(m13),
        m20(m20), m21(m21), m22(m22), m23(m23),
        m30(m30), m31(m31), m32(m32), m33(m33)
    {};

    static Matrix4f Identity()
    {
        return Matrix4f{
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        };
    }

    // from_json constructor, mij = data[i][j]
    Matrix4f(const nlohmann::json& data)
    {
        m00 = data[0][0]; m01 = data[0][1]; m02 = data[0][2]; m03 = data[0][3];
        m10 = data[1][0]; m11 = data[1][1]; m12 = data[1][2]; m13 = data[1][3];
        m20 = data[2][0]; m21 = data[2][1]; m22 = data[2][2]; m23 = data[2][3];
        m30 = data[3][0]; m31 = data[3][1]; m32 = data[3][2]; m33 = data[3][3];
    }

    // multiplication operator with float3 - simply assume the float3 makes a homegenous float4
    inline NRC_HOST_DEVICE float3 operator*(const float3& v) const
    {
        return make_float3(
            m00 * v.x + m01 * v.y + m02 * v.z + m03,
            m10 * v.x + m11 * v.y + m12 * v.z + m13,
            m20 * v.x + m21 * v.y + m22 * v.z + m23
        );
    }

    // convenience getter, returns the translation of this matrix as a float3
    inline NRC_HOST_DEVICE float3 get_translation() const
    {
        return make_float3(m03, m13, m23);
    }
};

// multiplication float * float3
inline NRC_HOST_DEVICE float3 operator*(const float& s, const float3& v)
{
    return make_float3(s * v.x, s * v.y, s * v.z);
}

// subtraction float3 - float3
inline NRC_HOST_DEVICE float3 operator-(const float3& a, const float3& b)
{
    return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
}

// l2 squared norm of a float3
inline NRC_HOST_DEVICE float l2_squared_norm(const float3& v)
{
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

NRC_NAMESPACE_END
